<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #FFFFFF; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFFFFF);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(18, 14, 18);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const RED = 0xDC2626;
        const BLACK = 0x171717;
        const GRAY = 0xD4D4D4;
        const MUTED = 0x737373;

        const blackMat = new THREE.MeshStandardMaterial({ color: BLACK, roughness: 0.8, metalness: 0.1 });
        const redMat = new THREE.MeshStandardMaterial({ color: RED, roughness: 0.4, metalness: 0.2 });
        const grayMat = new THREE.MeshStandardMaterial({ color: GRAY, roughness: 0.9, metalness: 0.05 });
        const mutedMat = new THREE.MeshStandardMaterial({ color: MUTED, roughness: 0.7, metalness: 0.1 });

        const vGeo = new THREE.BoxGeometry(1, 1, 1);

        // Scaffolding / Construction crane â€” building metaphor
        // Main structure being built
        const building = new THREE.Group();
        // Foundation
        for (let x = -3; x <= 3; x++) for (let z = -2; z <= 2; z++) {
            const m = new THREE.Mesh(vGeo, blackMat);
            m.position.set(x, 0, z);
            m.castShadow = true;
            building.add(m);
        }
        // Walls going up (partially built)
        for (let y = 1; y <= 6; y++) {
            for (let x = -3; x <= 3; x++) {
                if (x === -3 || x === 3) {
                    const m = new THREE.Mesh(vGeo, y > 4 ? mutedMat : grayMat);
                    m.position.set(x, y, -2);
                    m.castShadow = true;
                    building.add(m);
                    if (y <= 5) {
                        const m2 = new THREE.Mesh(vGeo, y > 4 ? mutedMat : grayMat);
                        m2.position.set(x, y, 2);
                        m2.castShadow = true;
                        building.add(m2);
                    }
                }
            }
        }
        // Red accent blocks (the "spark" of creation)
        const m1 = new THREE.Mesh(vGeo, redMat); m1.position.set(0, 7, 0); m1.castShadow = true; building.add(m1);
        const m2 = new THREE.Mesh(vGeo, redMat); m2.position.set(1, 7, 0); m2.castShadow = true; building.add(m2);
        const m3 = new THREE.Mesh(vGeo, redMat); m3.position.set(-1, 7, 0); m3.castShadow = true; building.add(m3);

        scene.add(building);

        // Crane arm
        const crane = new THREE.Group();
        // Vertical pole
        for (let y = 0; y <= 12; y++) {
            const m = new THREE.Mesh(vGeo, y > 10 ? redMat : blackMat);
            m.position.set(6, y, 0);
            m.castShadow = true;
            crane.add(m);
        }
        // Horizontal arm
        for (let x = -2; x <= 6; x++) {
            const m = new THREE.Mesh(vGeo, blackMat);
            m.position.set(x, 12, 0);
            m.castShadow = true;
            crane.add(m);
        }
        scene.add(crane);

        // Floating blocks descending from crane (being placed)
        const floaters = [];
        const floatData = [
            { target: new THREE.Vector3(0, 8, 0), delay: 0 },
            { target: new THREE.Vector3(2, 6, 1), delay: 1 },
            { target: new THREE.Vector3(-2, 5, 0), delay: 2 },
            { target: new THREE.Vector3(1, 5, -1), delay: 3 },
            { target: new THREE.Vector3(-1, 6, 1), delay: 4 },
            { target: new THREE.Vector3(0, 4, 2), delay: 1.5 },
            { target: new THREE.Vector3(2, 3, -2), delay: 2.5 },
        ];
        floatData.forEach(fd => {
            const m = new THREE.Mesh(vGeo, Math.random() > 0.7 ? redMat : grayMat);
            m.position.set(fd.target.x + (Math.random() - 0.5) * 2, 15 + Math.random() * 8, fd.target.z);
            m.castShadow = true;
            scene.add(m);
            floaters.push({ mesh: m, target: fd.target, delay: fd.delay, arrived: false, speed: 0.015 + Math.random() * 0.01 });
        });

        // Particles
        const particles = [];
        const pGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        for (let i = 0; i < 25; i++) {
            const p = new THREE.Mesh(pGeo, i % 4 === 0 ? redMat : mutedMat);
            p.position.set((Math.random() - 0.5) * 16, Math.random() * 15, (Math.random() - 0.5) * 12);
            scene.add(p);
            particles.push({ mesh: p, vy: 0.01 + Math.random() * 0.015 });
        }

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.set(1024, 1024);
        sun.shadow.camera.far = 50;
        sun.shadow.camera.left = -20; sun.shadow.camera.right = 20;
        sun.shadow.camera.top = 20; sun.shadow.camera.bottom = -20;
        scene.add(sun);

        const clock = new THREE.Clock();
        let angle = 0;

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            angle += 0.0005;
            camera.position.x = Math.cos(angle) * 24;
            camera.position.z = Math.sin(angle) * 24;
            camera.position.y = 14 + Math.sin(t * 0.06) * 1;
            camera.lookAt(0, 5, 0);

            floaters.forEach(f => {
                if (t < f.delay) return;
                if (f.arrived) {
                    f.mesh.position.y = f.target.y + Math.sin(t * 0.4 + f.delay) * 0.03;
                    return;
                }
                const dir = new THREE.Vector3().subVectors(f.target, f.mesh.position);
                const dist = dir.length();
                if (dist < 0.1) { f.mesh.position.copy(f.target); f.arrived = true; }
                else { dir.normalize().multiplyScalar(Math.min(f.speed * 0.3 * (1 + t * 0.04), dist)); f.mesh.position.add(dir); }
            });

            building.children.forEach((c, i) => {
                if (c.material === redMat) c.position.y = 7 + Math.sin(t * 0.5 + i) * 0.15;
            });

            particles.forEach(p => {
                p.mesh.position.y += p.vy * 0.2;
                p.mesh.rotation.x += 0.003;
                if (p.mesh.position.y > 16) { p.mesh.position.y = -1; p.mesh.position.x = (Math.random() - 0.5) * 16; }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
