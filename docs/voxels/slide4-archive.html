<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #FFFFFF; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFFFFF);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 8, 18);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const BLACK = 0x171717;
        const RED = 0xDC2626;
        const GRAY = 0xD4D4D4;
        const MUTED = 0x737373;

        const vGeo = new THREE.BoxGeometry(1, 1, 1);

        // Central rotating archive cube (3x3x3 open book shape)
        const archive = new THREE.Group();

        const blackMat = new THREE.MeshStandardMaterial({ color: BLACK, roughness: 0.6 });
        const redMat = new THREE.MeshStandardMaterial({ color: RED, roughness: 0.3, metalness: 0.2 });
        const grayMat = new THREE.MeshStandardMaterial({ color: GRAY, roughness: 0.8 });

        // Left page (5 tall, 4 wide, 1 deep)
        for (let x = -4; x <= -1; x++) {
            for (let y = 0; y < 5; y++) {
                const isEdge = x === -4 || y === 0 || y === 4;
                const mat = isEdge ? blackMat : grayMat;
                const m = new THREE.Mesh(vGeo, mat);
                m.position.set(x, y, 0);
                m.castShadow = true;
                archive.add(m);
            }
        }

        // Right page
        for (let x = 1; x <= 4; x++) {
            for (let y = 0; y < 5; y++) {
                const isEdge = x === 4 || y === 0 || y === 4;
                const mat = isEdge ? blackMat : grayMat;
                const m = new THREE.Mesh(vGeo, mat);
                m.position.set(x, y, 0);
                m.castShadow = true;
                archive.add(m);
            }
        }

        // Spine
        for (let y = 0; y < 5; y++) {
            const m = new THREE.Mesh(vGeo, redMat);
            m.position.set(0, y, 0);
            m.castShadow = true;
            archive.add(m);
        }

        // "Text lines" on left page (small red blocks)
        const lineGeo = new THREE.BoxGeometry(0.3, 0.15, 0.15);
        const lineMat = new THREE.MeshStandardMaterial({ color: RED, roughness: 0.5 });
        for (let row = 1; row <= 3; row++) {
            for (let col = 0; col < 3; col++) {
                const l = new THREE.Mesh(lineGeo, lineMat);
                l.position.set(-3 + col * 0.8, row, 0.55);
                archive.add(l);
            }
        }

        // "Text lines" on right page
        for (let row = 1; row <= 3; row++) {
            for (let col = 0; col < 3; col++) {
                const l = new THREE.Mesh(lineGeo, lineMat);
                l.position.set(2 + col * 0.8, row, 0.55);
                archive.add(l);
            }
        }

        archive.position.y = 2;
        scene.add(archive);

        // Memory particles floating out of the book
        const memCount = 50;
        const memGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        const memories = [];
        const memColors = [RED, BLACK, MUTED, GRAY];

        for (let i = 0; i < memCount; i++) {
            const col = memColors[Math.floor(Math.random() * memColors.length)];
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.5, transparent: true, opacity: 0.8 });
            const m = new THREE.Mesh(memGeo, mat);

            const angle = Math.random() * Math.PI * 2;
            const radius = 1 + Math.random() * 2;
            m.position.set(
                Math.cos(angle) * radius,
                2 + Math.random() * 3,
                Math.sin(angle) * radius
            );
            scene.add(m);

            memories.push({
                mesh: m,
                angle,
                radius: radius + Math.random() * 4,
                vy: 0.005 + Math.random() * 0.015,
                vAngle: 0.005 + Math.random() * 0.01,
                maxY: 10 + Math.random() * 5,
                startY: 2 + Math.random() * 2,
                phase: Math.random() * Math.PI * 2
            });
        }

        // Three smaller orbiting "memory cubes" (represent WS01, WS02, WS03)
        const orbitCubes = [];
        for (let i = 0; i < 3; i++) {
            const group = new THREE.Group();
            const size = 1.5;

            // Mini cube shell
            for (let x = 0; x < 2; x++) {
                for (let y = 0; y < 2; y++) {
                    for (let z = 0; z < 2; z++) {
                        const mat = (x + y + z) % 2 === 0 ? blackMat : grayMat;
                        const m = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
                        m.position.set((x - 0.5) * 0.7, (y - 0.5) * 0.7, (z - 0.5) * 0.7);
                        m.castShadow = true;
                        group.add(m);
                    }
                }
            }

            // Red accent on one face
            const accent = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.1), redMat);
            accent.position.set(0, 0, 0.4);
            group.add(accent);

            scene.add(group);
            orbitCubes.push({
                group,
                angle: (i / 3) * Math.PI * 2,
                radius: 7 + i,
                height: 3 + i * 1.5,
                speed: 0.3 + i * 0.1
            });
        }

        // No ground plane â€” pure white background

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 1.1);
        sun.position.set(8, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.set(1024, 1024);
        sun.shadow.camera.far = 50;
        sun.shadow.camera.left = -15;
        sun.shadow.camera.right = 15;
        sun.shadow.camera.top = 15;
        sun.shadow.camera.bottom = -15;
        scene.add(sun);
        const fill = new THREE.DirectionalLight(0xFFE8E0, 0.3);
        fill.position.set(-8, 8, -5);
        scene.add(fill);

        const clock = new THREE.Clock();
        let camAngle = 0;

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // Slow camera orbit (5x slower)
            camAngle += 0.0006;
            camera.position.x = Math.cos(camAngle) * 16;
            camera.position.z = Math.sin(camAngle) * 16;
            camera.position.y = 8 + Math.sin(t * 0.08) * 1;
            camera.lookAt(0, 3, 0);

            // Archive float + slow rotation (5x slower)
            archive.rotation.y = Math.sin(t * 0.06) * 0.3;
            archive.position.y = 2 + Math.sin(t * 0.16) * 0.3;

            // Memory particles spiral outward (5x slower)
            memories.forEach(m => {
                m.angle += m.vAngle * 0.2;
                m.mesh.position.x = Math.cos(m.angle) * m.radius;
                m.mesh.position.z = Math.sin(m.angle) * m.radius;
                m.mesh.position.y += m.vy * 0.2;
                m.mesh.rotation.x += 0.004;
                m.mesh.rotation.z += 0.003;

                // Fade out as they rise
                const progress = (m.mesh.position.y - m.startY) / (m.maxY - m.startY);
                m.mesh.material.opacity = Math.max(0, 1 - progress);

                if (m.mesh.position.y > m.maxY) {
                    m.mesh.position.y = m.startY;
                    m.radius = 1 + Math.random() * 2;
                    m.mesh.material.opacity = 0.8;
                }
            });

            // Orbit cubes (5x slower)
            orbitCubes.forEach(o => {
                o.angle += o.speed * 0.0016;
                o.group.position.x = Math.cos(o.angle) * o.radius;
                o.group.position.z = Math.sin(o.angle) * o.radius;
                o.group.position.y = o.height + Math.sin(t * 0.2 + o.angle) * 0.5;
                o.group.rotation.x += 0.002;
                o.group.rotation.y += 0.003;
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
