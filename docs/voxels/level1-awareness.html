<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #FFFFFF; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFFFFF);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(14, 12, 18);
        camera.lookAt(0, 4, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const BLACK = 0x171717;
        const RED = 0xDC2626;
        const GRAY = 0xD4D4D4;
        const MUTED = 0x737373;

        const blackMat = new THREE.MeshStandardMaterial({ color: BLACK, roughness: 0.8, metalness: 0.1 });
        const redMat = new THREE.MeshStandardMaterial({ color: RED, roughness: 0.4, metalness: 0.2 });
        const grayMat = new THREE.MeshStandardMaterial({ color: GRAY, roughness: 0.9, metalness: 0.05 });
        const mutedMat = new THREE.MeshStandardMaterial({ color: MUTED, roughness: 0.7, metalness: 0.1 });
        const vGeo = new THREE.BoxGeometry(1, 1, 1);

        // Lighthouse / Eye — metaphor for Awareness
        const lighthouse = new THREE.Group();
        function addV(x, y, z, mat = grayMat) {
            const m = new THREE.Mesh(vGeo, mat);
            m.position.set(x, y, z);
            m.castShadow = true;
            lighthouse.add(m);
            return m;
        }

        // Base (wide)
        for (let x = -2; x <= 2; x++) for (let z = -2; z <= 2; z++) addV(x, 0, z, blackMat);
        // Tower narrows
        for (let x = -1; x <= 1; x++) for (let z = -1; z <= 1; z++) addV(x, 1, z);
        for (let x = -1; x <= 1; x++) for (let z = -1; z <= 1; z++) addV(x, 2, z);
        addV(0, 3, 0); addV(1, 3, 0); addV(-1, 3, 0); addV(0, 3, 1); addV(0, 3, -1);
        addV(0, 4, 0); addV(1, 4, 0); addV(-1, 4, 0); addV(0, 4, 1); addV(0, 4, -1);
        addV(0, 5, 0); addV(0, 6, 0);
        // Lantern (red glowing top)
        addV(0, 7, 0, redMat);
        addV(1, 7, 0, redMat);
        addV(-1, 7, 0, redMat);
        addV(0, 7, 1, redMat);
        addV(0, 7, -1, redMat);
        addV(0, 8, 0, redMat);

        scene.add(lighthouse);

        // Light beams — voxel rays extending from lantern
        const beams = [];
        const beamDirs = [
            new THREE.Vector3(1, 0.2, 0),
            new THREE.Vector3(-1, 0.2, 0),
            new THREE.Vector3(0, 0.2, 1),
            new THREE.Vector3(0, 0.2, -1),
            new THREE.Vector3(0.7, 0.3, 0.7),
            new THREE.Vector3(-0.7, 0.3, -0.7),
        ];
        const beamGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const beamMat = new THREE.MeshStandardMaterial({ color: RED, roughness: 0.3, metalness: 0.1, transparent: true, opacity: 0.6 });
        beamDirs.forEach(dir => {
            for (let i = 1; i <= 8; i++) {
                const m = new THREE.Mesh(beamGeo, beamMat);
                m.position.set(dir.x * i * 1.2, 7.5 + dir.y * i, dir.z * i * 1.2);
                scene.add(m);
                beams.push({ mesh: m, baseY: 7.5 + dir.y * i, offset: i * 0.3, dist: i });
            }
        });

        // Floating question marks (small scattered voxels)
        const particles = [];
        const pGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        for (let i = 0; i < 30; i++) {
            const p = new THREE.Mesh(pGeo, i % 3 === 0 ? redMat : mutedMat);
            p.position.set((Math.random() - 0.5) * 16, Math.random() * 14, (Math.random() - 0.5) * 16);
            scene.add(p);
            particles.push({ mesh: p, vy: 0.008 + Math.random() * 0.012, phase: Math.random() * Math.PI * 2 });
        }

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.set(1024, 1024);
        scene.add(sun);
        scene.add(new THREE.DirectionalLight(0xDCE8FF, 0.4).translateX(-10).translateY(10));

        const clock = new THREE.Clock();
        let angle = 0;

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            angle += 0.0005;
            camera.position.x = Math.cos(angle) * 20;
            camera.position.z = Math.sin(angle) * 20;
            camera.position.y = 12 + Math.sin(t * 0.08) * 1;
            camera.lookAt(0, 4, 0);

            beams.forEach(b => {
                b.mesh.position.y = b.baseY + Math.sin(t * 0.5 + b.offset) * 0.15;
                b.mesh.material.opacity = 0.3 + Math.sin(t * 0.8 + b.offset) * 0.3;
            });

            particles.forEach(p => {
                p.mesh.position.y += p.vy * 0.2;
                p.mesh.rotation.x += 0.003;
                p.mesh.rotation.z += 0.002;
                if (p.mesh.position.y > 16) {
                    p.mesh.position.y = -1;
                    p.mesh.position.x = (Math.random() - 0.5) * 16;
                    p.mesh.position.z = (Math.random() - 0.5) * 16;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
